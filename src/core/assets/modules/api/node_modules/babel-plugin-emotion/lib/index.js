'use strict';

exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; //  weak


exports.hashArray = hashArray;
exports.hoistPureArgs = hoistPureArgs;
exports.replaceCssWithCallExpression = replaceCssWithCallExpression;
exports.buildStyledCallExpression = buildStyledCallExpression;
exports.buildStyledObjectCallExpression = buildStyledObjectCallExpression;

exports.default = function (babel) {
  var t = babel.types;


  return {
    name: 'emotion', // not required
    inherits: require('babel-plugin-syntax-jsx'),
    visitor: {
      Program: {
        enter: function enter(path, state) {
          state.importedNames = _extends({}, defaultImportedNames, state.opts.importedNames);

          var imports = [];

          var isModule = false;

          for (var _iterator = path.node.body, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
            var _ref;

            if (_isArray) {
              if (_i >= _iterator.length) break;
              _ref = _iterator[_i++];
            } else {
              _i = _iterator.next();
              if (_i.done) break;
              _ref = _i.value;
            }

            var node = _ref;

            if (t.isModuleDeclaration(node)) {
              isModule = true;
              break;
            }
          }

          if (isModule) {
            path.traverse({
              ImportDeclaration: {
                exit: function exit(path) {
                  var node = path.node;


                  var imported = [];
                  var specifiers = [];

                  imports.push({
                    source: node.source.value,
                    imported: imported,
                    specifiers: specifiers
                  });

                  for (var _iterator2 = path.get('specifiers'), _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
                    var _ref2;

                    if (_isArray2) {
                      if (_i2 >= _iterator2.length) break;
                      _ref2 = _iterator2[_i2++];
                    } else {
                      _i2 = _iterator2.next();
                      if (_i2.done) break;
                      _ref2 = _i2.value;
                    }

                    var specifier = _ref2;

                    var local = specifier.node.local.name;

                    if (specifier.isImportDefaultSpecifier()) {
                      imported.push('default');
                      specifiers.push({
                        kind: 'named',
                        imported: 'default',
                        local: local
                      });
                    }

                    if (specifier.isImportSpecifier()) {
                      var importedName = specifier.node.imported.name;
                      imported.push(importedName);
                      specifiers.push({
                        kind: 'named',
                        imported: importedName,
                        local: local
                      });
                    }
                  }
                }
              }
            });
          }

          imports.forEach(function (_ref3) {
            var source = _ref3.source,
                imported = _ref3.imported,
                specifiers = _ref3.specifiers;

            if (source.indexOf('emotion') !== -1) {
              var importedNames = specifiers.filter(function (v) {
                return ['default', 'css', 'keyframes', 'injectGlobal', 'fontFace', 'merge'].indexOf(v.imported) !== -1;
              }).reduce(function (acc, _ref4) {
                var _extends2;

                var imported = _ref4.imported,
                    local = _ref4.local;
                return _extends({}, acc, (_extends2 = {}, _extends2[imported === 'default' ? 'styled' : imported] = local, _extends2));
              }, defaultImportedNames);
              state.importedNames = _extends({}, importedNames, state.opts.importedNames);
            }
          });
          state.cssPropIdentifiers = [];
          state.extractStatic =
          // path.hub.file.opts.filename !== 'unknown' ||
          state.opts.extractStatic;

          state.staticRules = [];

          state.insertStaticRules = function (staticRules) {
            var _state$staticRules;

            (_state$staticRules = state.staticRules).push.apply(_state$staticRules, staticRules);
          };
        },
        exit: function exit(path, state) {
          if (state.staticRules.length !== 0) {
            var toWrite = state.staticRules.join('\n').trim();
            var filenameArr = path.hub.file.opts.filename.split('.');
            filenameArr.pop();
            filenameArr.push('emotion', 'css');
            var cssFilename = filenameArr.join('.');
            var exists = _fs2.default.existsSync(cssFilename);
            (0, _helperModuleImports.addSideEffect)(path, './' + (0, _path.basename)(cssFilename));
            if (exists ? _fs2.default.readFileSync(cssFilename, 'utf8') !== toWrite : true) {
              if (!exists) {
                (0, _touch.touchSync)(cssFilename);
              }
              _fs2.default.writeFileSync(cssFilename, toWrite);
            }
          }
        }
      },
      JSXOpeningElement: function JSXOpeningElement(path, state) {
        (0, _cssProp2.default)(path, state, t);
        if (state.opts.hoist) {
          path.traverse({
            CallExpression: function CallExpression(callExprPath) {
              if (callExprPath.node.callee.name === state.importedNames.css || state.cssPropIdentifiers.indexOf(callExprPath.node.callee) !== -1) {
                hoistPureArgs(callExprPath);
              }
            }
          });
        }
      },

      CallExpression: {
        enter: function enter(path, state) {
          if (path[visited]) {
            return;
          }
          try {
            if (t.isIdentifier(path.node.callee)) {
              switch (path.node.callee.name) {
                case state.importedNames.css:
                case state.importedNames.keyframes:
                  {
                    path.addComment('leading', '#__PURE__');
                    if (state.opts.autoLabel) {
                      var identifierName = (0, _babelUtils.getIdentifierName)(path, t);
                      if (identifierName) {
                        path.node.arguments.push(t.stringLiteral('label:' + identifierName.trim() + ';'));
                      }
                    }
                  }
                // eslint-disable-next-line no-fallthrough
                case state.importedNames.injectGlobal:
                case state.importedNames.fontFace:
                  if (state.opts.sourceMap === true && path.node.loc !== undefined) {
                    path.node.arguments.push(t.stringLiteral((0, _sourceMap.addSourceMaps)(path.node.loc.start, state)));
                  }
              }
            }

            if (t.isCallExpression(path.node.callee) && path.node.callee.callee.name === state.importedNames.styled || t.isMemberExpression(path.node.callee) && t.isIdentifier(path.node.callee.object) && path.node.callee.object.name === state.importedNames.styled) {
              var identifier = t.isCallExpression(path.node.callee) ? path.node.callee.callee : path.node.callee.object;
              path.replaceWith(buildStyledObjectCallExpression(path, state, identifier, t));

              if (state.opts.hoist) {
                hoistPureArgs(path);
              }
            }
          } catch (e) {
            throw path.buildCodeFrameError(e);
          }

          path[visited] = true;
        },
        exit: function exit(path, state) {
          try {
            if (path.node.callee && path.node.callee.property && path.node.callee.property.name === 'withComponent') {
              if (path.node.arguments.length === 1) {
                path.node.arguments.push(t.objectExpression([buildTargetObjectProperty(path, state, t)]));
              }
            }
          } catch (e) {
            throw path.buildCodeFrameError(e);
          }
        }
      },
      TaggedTemplateExpression: function TaggedTemplateExpression(path, state) {
        if (path[visited]) {
          return;
        }
        path[visited] = true;
        if (
        // styled.h1`color:${color};`
        t.isMemberExpression(path.node.tag) && path.node.tag.object.name === state.importedNames.styled) {
          path.replaceWith(buildStyledCallExpression(path.node.tag.object, t.stringLiteral(path.node.tag.property.name), path, state, t));
        } else if (
        // styled('h1')`color:${color};`
        t.isCallExpression(path.node.tag) && path.node.tag.callee.name === state.importedNames.styled) {
          path.replaceWith(buildStyledCallExpression(path.node.tag.callee, path.node.tag.arguments[0], path, state, t));
        } else if (t.isIdentifier(path.node.tag)) {
          if (path.node.tag.name === state.importedNames.css || state.cssPropIdentifiers.indexOf(path.node.tag) !== -1) {
            replaceCssWithCallExpression(path, path.node.tag, state, t);
          } else if (path.node.tag.name === state.importedNames.keyframes) {
            replaceCssWithCallExpression(path, path.node.tag, state, t, function (src, name, hash) {
              return '@keyframes ' + name + '-' + hash + ' { ' + src + ' }';
            }, false, function () {
              return '';
            });
          } else if (path.node.tag.name === state.importedNames.fontFace) {
            replaceCssWithCallExpression(path, path.node.tag, state, t, function (src, name, hash) {
              return '@font-face {' + src + '}';
            }, true);
          } else if (path.node.tag.name === state.importedNames.injectGlobal) {
            replaceCssWithCallExpression(path, path.node.tag, state, t, undefined, true, function () {
              return '';
            });
          }
        }
      }
    }
  };
};

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _findRoot = require('find-root');

var _findRoot2 = _interopRequireDefault(_findRoot);

var _path = require('path');

var _touch = require('touch');

var _helperModuleImports = require('@babel/helper-module-imports');

var _babelUtils = require('./babel-utils');

var _emotionUtils = require('emotion-utils');

var _sourceMap = require('./source-map');

var _cssProp = require('./css-prop');

var _cssProp2 = _interopRequireDefault(_cssProp);

var _astObject = require('./ast-object');

var _astObject2 = _interopRequireDefault(_astObject);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function hashArray(arr) {
  return (0, _emotionUtils.hashString)(arr.join(''));
}

var staticStylis = new _emotionUtils.Stylis({ keyframe: false });

function hoistPureArgs(path) {
  var args = path.get('arguments');

  if (args && Array.isArray(args)) {
    args.forEach(function (arg) {
      if (!arg.isIdentifier() && arg.isPure()) {
        arg.hoist();
      }
    });
  }
}

function replaceCssWithCallExpression(path, identifier, state, t) {
  var staticCSSSrcCreator = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : function (src) {
    return src;
  };
  var removePath = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
  var staticCSSSelectorCreator = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : function (name, hash) {
    return '.' + name + '-' + hash;
  };

  try {
    var _createRawStringFromT = (0, _babelUtils.createRawStringFromTemplateLiteral)(path.node.quasi),
        hash = _createRawStringFromT.hash,
        src = _createRawStringFromT.src;

    var identifierName = (0, _babelUtils.getIdentifierName)(path, t);
    var name = (0, _babelUtils.getName)(identifierName, 'css');

    if (state.extractStatic && !path.node.quasi.expressions.length) {
      var staticCSSRules = staticStylis(staticCSSSelectorCreator(name, hash), staticCSSSrcCreator(src, name, hash));
      state.insertStaticRules([staticCSSRules]);
      if (!removePath) {
        return path.replaceWith(t.stringLiteral(name + '-' + hash));
      }
      return path.replaceWith(t.identifier('undefined'));
    }

    if (!removePath) {
      path.addComment('leading', '#__PURE__');
    }
    if (state.opts.sourceMap === true && path.node.quasi.loc !== undefined) {
      src += (0, _sourceMap.addSourceMaps)(path.node.quasi.loc.start, state);
    }

    path.replaceWith(t.callExpression(identifier, new _astObject2.default((0, _babelUtils.minify)(src), path.node.quasi.expressions, t).toExpressions().concat(state.opts.autoLabel && identifierName ? [t.stringLiteral('label:' + identifierName.trim() + ';')] : [])));

    if (state.opts.hoist) {
      hoistPureArgs(path);
    }

    return;
  } catch (e) {
    if (path) {
      throw path.buildCodeFrameError(e);
    }

    throw e;
  }
}

var getPackageRootPath = (0, _emotionUtils.memoize)(function (filename) {
  return (0, _findRoot2.default)(filename);
});

function buildTargetObjectProperty(path, state, t) {
  if (state.count === undefined) {
    state.count = 0;
  }

  var filename = state.file.opts.filename;

  // normalize the file path to ignore folder structure
  // outside the current node project and arch-specific delimiters
  var moduleName = '';
  var rootPath = filename;

  try {
    rootPath = getPackageRootPath(filename);
    moduleName = require(rootPath + '/package.json').name;
  } catch (err) {}

  var finalPath = filename === rootPath ? (0, _path.basename)(filename) : filename.slice(rootPath.length);

  var positionInFile = state.count++;
  var stableClassName = (0, _babelUtils.getName)('' + hashArray([(0, _path.normalize)(finalPath), moduleName, state.file.code]) + positionInFile, 'css');

  return t.objectProperty(t.identifier('target'), t.stringLiteral(stableClassName));
}

function buildStyledCallExpression(identifier, tag, path, state, t) {
  var identifierName = (0, _babelUtils.getIdentifierName)(path, t);

  var targetProperty = buildTargetObjectProperty(path, state, t);

  if (state.extractStatic && !path.node.quasi.expressions.length) {
    var _createRawStringFromT2 = (0, _babelUtils.createRawStringFromTemplateLiteral)(path.node.quasi, identifierName, 'styled' // we don't want these styles to be merged in css``
    ),
        hash = _createRawStringFromT2.hash,
        _src = _createRawStringFromT2.src;

    var staticClassName = (0, _babelUtils.getName)(hash, 'css');
    var staticCSSRules = staticStylis('.' + staticClassName, _src);

    state.insertStaticRules([staticCSSRules]);

    return t.callExpression(t.callExpression(identifier, [tag, t.objectExpression([t.objectProperty(t.identifier('e'), t.stringLiteral(staticClassName)), targetProperty])]), []);
  }

  var _createRawStringFromT3 = (0, _babelUtils.createRawStringFromTemplateLiteral)(path.node.quasi),
      src = _createRawStringFromT3.src;

  path.addComment('leading', '#__PURE__');

  if (state.opts.sourceMap === true && path.node.quasi.loc !== undefined) {
    src += (0, _sourceMap.addSourceMaps)(path.node.quasi.loc.start, state);
  }

  var labelProperty = void 0;

  if (state.opts.autoLabel && identifierName) {
    labelProperty = t.objectProperty(t.identifier('label'), t.stringLiteral(identifierName.trim()));
  }

  return t.callExpression(t.callExpression(identifier, [tag, t.objectExpression([labelProperty, targetProperty].filter(Boolean))]), new _astObject2.default((0, _babelUtils.minify)(src), path.node.quasi.expressions, t).toExpressions());
}

function buildStyledObjectCallExpression(path, state, identifier, t) {
  var identifierName = (0, _babelUtils.getIdentifierName)(path, t);
  var tag = t.isCallExpression(path.node.callee) ? path.node.callee.arguments[0] : t.stringLiteral(path.node.callee.property.name);

  var args = path.node.arguments;
  if (state.opts.sourceMap === true && path.node.loc !== undefined) {
    args.push(t.stringLiteral((0, _sourceMap.addSourceMaps)(path.node.loc.start, state)));
  }

  path.addComment('leading', '#__PURE__');

  return t.callExpression(t.callExpression(identifier, state.opts.autoLabel && identifierName ? [tag, t.objectExpression([t.objectProperty(t.identifier('label'), t.stringLiteral(identifierName.trim()))])] : [tag]), args);
}

var visited = Symbol('visited');

var defaultImportedNames = {
  styled: 'styled',
  css: 'css',
  keyframes: 'keyframes',
  injectGlobal: 'injectGlobal',
  fontFace: 'fontFace',
  merge: 'merge'
};