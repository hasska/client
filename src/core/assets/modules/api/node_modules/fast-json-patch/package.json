{
  "_args": [
    [
      {
        "raw": "fast-json-patch@^2.0.6",
        "scope": null,
        "escapedName": "fast-json-patch",
        "name": "fast-json-patch",
        "rawSpec": "^2.0.6",
        "spec": ">=2.0.6 <3.0.0",
        "type": "range"
      },
      "/Users/vt/Desktop/projects/newv1/node_modules/swagger-client"
    ]
  ],
  "_from": "fast-json-patch@>=2.0.6 <3.0.0",
  "_id": "fast-json-patch@2.0.6",
  "_inCache": true,
  "_location": "/fast-json-patch",
  "_nodeVersion": "6.10.3",
  "_npmOperationalInternal": {
    "host": "s3://npm-registry-packages",
    "tmp": "tmp/fast-json-patch-2.0.6.tgz_1508510061149_0.3035558396950364"
  },
  "_npmUser": {
    "name": "alshakero",
    "email": "omar@omaralshaker.com"
  },
  "_npmVersion": "3.10.10",
  "_phantomChildren": {},
  "_requested": {
    "raw": "fast-json-patch@^2.0.6",
    "scope": null,
    "escapedName": "fast-json-patch",
    "name": "fast-json-patch",
    "rawSpec": "^2.0.6",
    "spec": ">=2.0.6 <3.0.0",
    "type": "range"
  },
  "_requiredBy": [
    "/swagger-client"
  ],
  "_resolved": "https://registry.npmjs.org/fast-json-patch/-/fast-json-patch-2.0.6.tgz",
  "_shasum": "86fff8f8662391aa819722864d632e603e6ee605",
  "_shrinkwrap": null,
  "_spec": "fast-json-patch@^2.0.6",
  "_where": "/Users/vt/Desktop/projects/newv1/node_modules/swagger-client",
  "author": {
    "name": "Joachim Wester",
    "email": "joachimwester@me.com",
    "url": "http://www.starcounter.com/"
  },
  "bugs": {
    "url": "https://github.com/Starcounter-Jack/JSON-Patch/issues"
  },
  "dependencies": {
    "deep-equal": "^1.0.1"
  },
  "description": "Fast implementation of JSON-Patch (RFC-6902) with duplex (observe changes) capabilities",
  "devDependencies": {
    "babili-webpack-plugin": "^0.1.1",
    "benchmark": "^2.1.2",
    "chalk": "^1.1.3",
    "jasmine": "^2.5.1",
    "jsdom": "^9.5.0",
    "jsonfile": "^2.3.1",
    "typescript": "~2.0.0",
    "underscore": "^1.8.3",
    "webpack": "^2.6.1"
  },
  "directories": {},
  "dist": {
    "shasum": "86fff8f8662391aa819722864d632e603e6ee605",
    "tarball": "https://registry.npmjs.org/fast-json-patch/-/fast-json-patch-2.0.6.tgz"
  },
  "engines": {
    "node": ">= 0.4.0"
  },
  "gitHead": "370688902c3cdf67a5d86788708c8b9d3373a62e",
  "homepage": "https://github.com/Starcounter-Jack/JSON-Patch",
  "keywords": [
    "json",
    "patch",
    "http",
    "rest"
  ],
  "license": "MIT",
  "main": "lib/duplex.js",
  "maintainers": [
    {
      "name": "alshakero",
      "email": "omar@omaralshaker.com"
    },
    {
      "name": "tomalec",
      "email": "tomalecwp@gmail.com"
    },
    {
      "name": "warpech",
      "email": "warpech@gmail.com"
    }
  ],
  "name": "fast-json-patch",
  "optionalDependencies": {},
  "readme": "JSON-Patch\r\n===============\r\n\r\n> A leaner and meaner implementation of JSON-Patch. Small footprint. High performance.\r\n\r\n[![Build Status](https://travis-ci.org/Starcounter-Jack/JSON-Patch.svg?branch=master)](https://travis-ci.org/Starcounter-Jack/JSON-Patch)\r\n\r\nWith JSON-Patch, you can:\r\n- **applyPatch** to apply patches\r\n- **applyOperation** to apply single operations\r\n- **validate** a sequence of patches\r\n- **observe** for changes (and generate patches when a change is detected)\r\n- **compare** two objects (to obtain the difference)\r\n\r\n## Why you should use JSON-Patch\r\n\r\nJSON-Patch [(RFC6902)](http://tools.ietf.org/html/rfc6902) is a standard format that\r\nallows you to update a JSON document by sending the changes rather than the whole document.\r\nJSON Patch plays well with the HTTP PATCH verb (method) and REST style programming.\r\n\r\nMark Nottingham has a [nice blog]( http://www.mnot.net/blog/2012/09/05/patch) about it.\r\n\r\n## Footprint\r\n4 KB minified and gzipped (12 KB minified)\r\n\r\n## Performance\r\n\r\n##### [`add` benchmark](https://run.perf.zone/view/JSON-Patch-Add-Operation-1500650502896)\r\n\r\n![image](https://user-images.githubusercontent.com/17054134/28513264-b0c8eede-7055-11e7-8204-4536d871e971.png)\r\n\r\n##### [`replace` benchmark](https://run.perf.zone/view/JSON-Patch-Replace-Operation-1500645548223)\r\n\r\n![image](https://user-images.githubusercontent.com/17054134/28513298-d8c927a0-7055-11e7-9a4e-2da024655ac0.png)\r\n\r\nTested on 24.07.2017. Compared libraries:\r\n\r\n- [Starcounter-Jack/JSON-Patch](https://www.npmjs.com/package/fast-json-patch) 2.0.4\r\n- [bruth/jsonpatch-js](https://www.npmjs.com/package/json-patch) 0.6.1\r\n- [dharmafly/jsonpatch.js](https://www.npmjs.com/package/jsonpatch) 3.0.0\r\n- [jiff](https://www.npmjs.com/package/jiff) 0.7.3\r\n\r\nWe aim the tests to be fair. Our library puts performance as the #1 priority, while other libraries can have different priorities. If you'd like to update the benchmarks or add a library, please fork  the [perf.zone](https://perf.zone) benchmarks linked above and open an issue to include new results.\r\n\r\n## Features\r\n* Allows you to apply patches on object trees for incoming traffic.\r\n* Allows you to freely manipulate object trees and then generate patches for outgoing traffic.\r\n* Tested in IE 8-11, Firefox, Chrome, Safari and Node.js\r\n\r\n\r\n## Install\r\n\r\nInstall the current version (and save it as a dependency):\r\n\r\n### npm\r\n\r\n```sh\r\n$ npm install fast-json-patch --save\r\n```\r\n### bower\r\n\r\n```sh\r\n$ bower install fast-json-patch --save\r\n```\r\n\r\n### [download as ZIP](https://github.com/Starcounter-Jack/JSON-Patch/archive/master.zip)\r\n\r\n\r\n## Adding to your project\r\n\r\n### In a web browser\r\n\r\nInclude `dist/fast-json-patch.js`.\r\n\r\n### In Node.js\r\n\r\nCall require to get the instance:\r\n\r\n```js\r\nvar jsonpatch = require('fast-json-patch')\r\n```\r\n\r\nOr use ES6 style:\r\n\r\n```js\r\nimport { applyOperation } from 'fast-json-patch'\r\n```\r\n\r\nYou can also require all API functions individually, all jsonpatch functions can be used as pure functions:\r\n\r\n```js\r\nconst { applyOperation } = require('fast-json-patch');\r\n```\r\n\r\n## Usage\r\n\r\n#### Applying patches:\r\n\r\n```js\r\nvar document = { firstName: \"Albert\", contactDetails: { phoneNumbers: [] } };\r\nvar patch = [\r\n  { op: \"replace\", path: \"/firstName\", value: \"Joachim\" },\r\n  { op: \"add\", path: \"/lastName\", value: \"Wester\" },\r\n  { op: \"add\", path: \"/contactDetails/phoneNumbers/0\", value: { number: \"555-123\" }  }\r\n];\r\ndocument = jsonpatch.applyPatch(document, patch).newDocument;\r\n// document == { firstName: \"Joachim\", lastName: \"Wester\", contactDetails: { phoneNumbers: [{number:\"555-123\"}] } };\r\n```\r\n\r\n##### For apply individual operations you can use `applyOperation`\r\n\r\n`jsonpatch.applyOperation` accepts a single operation object instead of a sequence, and returns the object after applying the operation. It works with all the standard JSON patch operations (`add, replace, move, test, remove and copy`).\r\n\r\n```js\r\nvar document = { firstName: \"Albert\", contactDetails: { phoneNumbers: [] } };\r\nvar operation = { op: \"replace\", path: \"/firstName\", value: \"Joachim\" };\r\ndocument = jsonpatch.applyOperation(document, operation).newDocument;\r\n// document == { firstName: \"Joachim\", contactDetails: { phoneNumbers: [] }}\r\n```\r\n\r\n#### Using `applyReducer` with `reduce`\r\n\r\nIf you have an array of operations, you can simple reduce them using `applyReducer` as your reducer:\r\n\r\n```js\r\nvar document = { firstName: \"Albert\", contactDetails: { phoneNumbers: [ ] } };\r\nvar patch = [\r\n  { op:\"replace\", path: \"/firstName\", value: \"Joachim\" },\r\n  { op:\"add\", path: \"/lastName\", value: \"Wester\" },\r\n  { op:\"add\", path: \"/contactDetails/phoneNumbers/0\", value: { number: \"555-123\" } }\r\n];\r\nvar updatedDocument = patch.reduce(applyReducer, document);\r\n// updatedDocument == { firstName:\"Joachim\", lastName:\"Wester\", contactDetails:{ phoneNumbers[ {number:\"555-123\"} ] } };\r\n```\r\n\r\nGenerating patches:\r\n\r\n```js\r\nvar document = { firstName: \"Joachim\", lastName: \"Wester\", contactDetails: { phoneNumbers: [ { number:\"555-123\" }] } };\r\nvar observer = jsonpatch.observe(document);\r\ndocument.firstName = \"Albert\";\r\ndocument.contactDetails.phoneNumbers[0].number = \"123\";\r\ndocument.contactDetails.phoneNumbers.push({ number:\"456\" });\r\nvar patch = jsonpatch.generate(observer);\r\n// patch  == [\r\n//   { op: \"replace\", path: \"/firstName\", value: \"Albert\"},\r\n//   { op: \"replace\", path: \"/contactDetails/phoneNumbers/0/number\", value: \"123\" },\r\n//   { op: \"add\", path: \"/contactDetails/phoneNumbers/1\", value: {number:\"456\"}}\r\n// ];\r\n```\r\n\r\nComparing two object trees:\r\n\r\n```js\r\nvar documentA = {user: {firstName: \"Albert\", lastName: \"Einstein\"}};\r\nvar documentB = {user: {firstName: \"Albert\", lastName: \"Collins\"}};\r\nvar diff = jsonpatch.compare(documentA, documentB));\r\n//diff == [{op: \"replace\", path: \"/user/lastName\", value: \"Collins\"}]\r\n```\r\n\r\nValidating a sequence of patches:\r\n\r\n```js\r\nvar obj = {user: {firstName: \"Albert\"}};\r\nvar patches = [{op: \"replace\", path: \"/user/firstName\", value: \"Albert\"}, {op: \"replace\", path: \"/user/lastName\", value: \"Einstein\"}];\r\nvar errors = jsonpatch.validate(patches, obj);\r\nif (errors.length == 0) {\r\n //there are no errors!\r\n}\r\nelse {\r\n  for (var i=0; i < errors.length; i++) {\r\n    if (!errors[i]) {\r\n      console.log(\"Valid patch at index\", i, patches[i]);\r\n    }\r\n    else {\r\n      console.error(\"Invalid patch at index\", i, errors[i], patches[i]);\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n## API\r\n\r\n#### `jsonpatch.applyPatch<T>(document: any, patch: Operation[], validateOperation: Boolean | Function = false): OperationResult<T>[]`\r\n\r\nApplies `patch` array on `obj`.\r\n\r\nAn invalid patch results in throwing an error (see `jsonpatch.validate` for more information about the error object).\r\n\r\nIt modifies the `document` object and `patch` - it gets the values by reference.\r\nIf you would like to avoid touching your values, clone them: `jsonpatch.applyPatch(document, jsonpatch.deepClone(patch))`.\r\n\r\nReturns an array of [`OperationResult`](#operationresult-type) objects - one item for each item in `patches`, each item is an object `{newDocument: any, test?: boolean, removed?: any}`.\r\n\r\n* `test` - boolean result of the test\r\n* `remove`, `replace` and `move` - original object that has been removed\r\n* `add` (only when adding to an array) - index at which item has been inserted (useful when using `-` alias)\r\n\r\n** Note: It throws `TEST_OPERATION_FAILED` error if `test` operation fails. **\r\n\r\n** Note II: the returned array has `newDocument` property that you can use as the final state of the patched document **.\r\n\r\n- See [Validation notes](#validation-notes).\r\n\r\n#### `applyOperation<T>(document: any, operation: Operation, validateOperation: <Boolean | Function> = false, mutateDocument = true): OperationResult<T>`\r\n\r\nApplies single operation object `operation` on `document`.\r\n\r\n- `document` The document to patch\r\n- `operation` The operation to apply\r\n- `validateOperation` Whether to validate the operation, or to pass a validator callback\r\n- `mutateDocument` Whether to mutate the original document or clone it before applying\r\n\r\nIt modifies the `document` object and `operation` - it gets the values by reference.\r\nIf you would like to avoid touching your values, clone them: `jsonpatch.applyOperation(document, jsonpatch.deepClone(operation))`.\r\n\r\nReturns an [`OperationResult`](#operationresult-type) object `{newDocument: any, test?: boolean, removed?: any}`.\r\n\r\n** Note: It throws `TEST_OPERATION_FAILED` error if `test` operation fails. **\r\n\r\n- See [Validation notes](#validation-notes).\r\n\r\n#### `jsonpatch.applyReducer<T>(document: T, operation: Operation): T`\r\n\r\n**Ideal for `patch.reduce(jsonpatch.applyReducer, document)`**.\r\n\r\nApplies single operation object `operation` on `document`.\r\n\r\nReturns the a modified document.\r\n\r\nNote: It throws `TEST_OPERATION_FAILED` error if `test` operation fails.\r\n\r\n#### `jsonpatch.deepClone(value: any): any`\r\n\r\nReturns deeply cloned value.\r\n\r\n#### `jsonpatch.escapePathComponent(path: string): string`\r\n\r\nReturns the escaped path.\r\n\r\n#### `jsonpatch.unescapePathComponent(path: string): string`\r\n\r\nReturns the unescaped path.\r\n\r\n#### `jsonpatch.getValueByPointer(document: object, pointer: string)`\r\n\r\nRetrieves a value from a JSON document by a JSON pointer.\r\n\r\nReturns the value.\r\n\r\n#### `jsonpatch.observe(document: any, callback?: Function): Observer`\r\n\r\nSets up an deep observer on `document` that listens for changes in object tree. When changes are detected, the optional\r\ncallback is called with the generated patches array as the parameter.\r\n\r\nReturns `observer`.\r\n\r\n#### `jsonpatch.generate(document: any, observer: Observer): Operation[]`\r\n\r\nIf there are pending changes in `obj`, returns them synchronously. If a `callback` was defined in `observe`\r\nmethod, it will be triggered synchronously as well.\r\n\r\nIf there are no pending changes in `obj`, returns an empty array (length 0).\r\n\r\n#### `jsonpatch.unobserve(document: any, observer: Observer): void`\r\n\r\nDestroys the observer set up on `document`.\r\n\r\nAny remaining changes are delivered synchronously (as in `jsonpatch.generate`). Note: this is different that ES6/7 `Object.unobserve`, which delivers remaining changes asynchronously.\r\n\r\n#### `jsonpatch.compare(document1: any, document2: any): Operation[]`\r\n\r\nCompares object trees `document1` and `document2` and returns the difference relative to `document1` as a patches array.\r\n\r\nIf there are no differences, returns an empty array (length 0).\r\n\r\n#### `jsonpatch.validate(patch: Operation[], document?: any, validator?: Function): JsonPatchError`\r\n\r\nSee [Validation notes](#validation-notes)\r\n\r\nValidates a sequence of operations. If `document` parameter is provided, the sequence is additionally validated against the object tree.\r\n\r\nIf there are no errors, returns undefined. If there is an errors, returns a JsonPatchError object with the following properties:\r\n\r\n- `name` String - short error code\r\n- `message` String - long human readable error message\r\n- `index` Number - index of the operation in the sequence\r\n- `operation` Object - reference to the operation\r\n- `tree` Object - reference to the tree\r\n\r\nPossible errors:\r\n\r\nError name                    | Error message\r\n------------------------------|------------\r\nSEQUENCE_NOT_AN_ARRAY         | Patch sequence must be an array\r\nOPERATION_NOT_AN_OBJECT       | Operation is not an object\r\nOPERATION_OP_INVALID          | Operation `op` property is not one of operations defined in RFC-6902\r\nOPERATION_PATH_INVALID        | Operation `path` property is not a valid string\r\nOPERATION_FROM_REQUIRED       | Operation `from` property is not present (applicable in `move` and `copy` operations)\r\nOPERATION_VALUE_REQUIRED      | Operation `value` property is not present, or `undefined` (applicable in `add`, `replace` and `test` operations)\r\nOPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED  | Operation `value` property object has at least one `undefined` value (applicable in `add`, `replace` and `test` operations)\r\nOPERATION_PATH_CANNOT_ADD     | Cannot perform an `add` operation at the desired path\r\nOPERATION_PATH_UNRESOLVABLE   | Cannot perform the operation at a path that does not exist\r\nOPERATION_FROM_UNRESOLVABLE   | Cannot perform the operation from a path that does not exist\r\nOPERATION_PATH_ILLEGAL_ARRAY_INDEX | Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index\r\nOPERATION_VALUE_OUT_OF_BOUNDS | The specified index MUST NOT be greater than the number of elements in the array\r\nTEST_OPERATION_FAILED | When operation is `test` and the test fails, applies to `applyReducer`.\r\n\r\n## `OperationResult` Type\r\n\r\nFunctions `applyPatch` and `applyOperation` both return `OperationResult` object. This object is:\r\n\r\n```ts\r\n{newDocument: any, test?: boolean, removed?: any}\r\n```\r\n\r\nWhere:\r\n\r\n- `newDocument`: the new state of the document after the patch/operation is applied.\r\n- `test`: if the operation was a `test` operation. This will be its result.\r\n- `removed`: contains the removed, moved, or replaced values from the document after a `remove`, `move` or `replace` operation.\r\n\r\n\r\n## Validation Notes\r\n\r\nFunctions `applyPatch`, `applyOperation`, and `validate` accept a `validate`/ `validator` parameter:\r\n\r\n- If the `validateOperation` parameter is set to `false`, validation will not occur.\r\n- If set to `true`, the patch is extensively validated before applying using jsonpatch's default validation.\r\n- If set to a `function` callback, the patch is validated using that function.\r\n\r\nIf you pass a validator, it will be called with four parameters for each operation, `function(operation, index, tree, existingPath)` and it is expected to throw `JsonPatchError` when your conditions are not met.\r\n\r\n- `operation` The operation it self.\r\n- `index` `operation`'s index in the patch array (if application).  \r\n- `tree` The object that is supposed to be patched.\r\n- `existingPath` the path `operation` points to.\r\n\r\n## Overwriting and `move` Operation\r\n\r\nWhen the target of the move operation already exists, it is cached, deep cloned and returned as `removed` in `OperationResult`.\r\n\r\n## `undefined`s (JS to JSON projection)\r\n\r\nAs `undefined` type does not exist in JSON, it's also not a valid value of JSON Patch operation. Therefore `jsonpatch` will not generate JSON Patches that sets anything to `undefined`.\r\n\r\nWhenever a value is set to `undefined` in JS, JSON-Patch methods `generate` and `compare` will treat it similarly to how JavaScript method [`JSON.stringify` (MDN)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify) treats them:\r\n\r\n> If `undefined` (...) is encountered during conversion it is either omitted (when it is found in an object) or censored to `null` (when it is found in an array).\r\n\r\nSee the [ECMAScript spec](http://www.ecma-international.org/ecma-262/6.0/index.html#sec-json.stringify) for details.\r\n\r\n## Specs/tests\r\n\r\n - [Run in browser](http://starcounter-jack.github.io/JSON-Patch/test/)\r\n\r\n## [Contributing](CONTRIBUTING.md)\r\n\r\n## Changelog\r\n\r\nTo see the list of recent changes, see [Releases](https://github.com/Starcounter-Jack/JSON-Patch/releases).\r\n\r\n## License\r\n\r\nMIT\r\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git://github.com/Starcounter-Jack/JSON-Patch.git"
  },
  "scripts": {
    "bench": "npm run bench-core && npm run bench-duplex",
    "bench-core": "node test/spec/coreBenchmark.js",
    "bench-duplex": "node test/spec/coreBenchmark.js DUPLEX=yes && node test/spec/duplexBenchmark.js",
    "build": "tsc && webpack",
    "test": "npm run tsc && npm run test-core && npm run test-duplex",
    "test-core": "jasmine  DUPLEX=no JASMINE_CONFIG_PATH=test/jasmine.json test/spec/jsonPatchTestsSpec.js test/spec/coreSpec.js test/spec/validateSpec.js",
    "test-duplex": "jasmine DUPLEX=yes JASMINE_CONFIG_PATH=test/jasmine.json",
    "tsc": "tsc",
    "tsc-watch": "tsc -w",
    "version": "tsc && webpack && git add -A"
  },
  "typings": "lib/duplex.d.ts",
  "version": "2.0.6"
}
