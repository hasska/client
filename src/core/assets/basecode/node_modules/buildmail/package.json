{
  "_args": [
    [
      {
        "raw": "buildmail@4.0.1",
        "scope": null,
        "escapedName": "buildmail",
        "name": "buildmail",
        "rawSpec": "4.0.1",
        "spec": "4.0.1",
        "type": "version"
      },
      "/Users/vt/Documents/development/canada/src/core/assets/basecode/node_modules/mailcomposer"
    ]
  ],
  "_from": "buildmail@4.0.1",
  "_id": "buildmail@4.0.1",
  "_inCache": true,
  "_location": "/buildmail",
  "_nodeVersion": "6.9.1",
  "_npmOperationalInternal": {
    "host": "packages-18-east.internal.npmjs.com",
    "tmp": "tmp/buildmail-4.0.1.tgz_1483528399213_0.7746030108537525"
  },
  "_npmUser": {
    "name": "andris",
    "email": "andris@kreata.ee"
  },
  "_npmVersion": "3.10.8",
  "_phantomChildren": {},
  "_requested": {
    "raw": "buildmail@4.0.1",
    "scope": null,
    "escapedName": "buildmail",
    "name": "buildmail",
    "rawSpec": "4.0.1",
    "spec": "4.0.1",
    "type": "version"
  },
  "_requiredBy": [
    "/mailcomposer"
  ],
  "_resolved": "https://registry.npmjs.org/buildmail/-/buildmail-4.0.1.tgz",
  "_shasum": "877f7738b78729871c9a105e3b837d2be11a7a72",
  "_shrinkwrap": null,
  "_spec": "buildmail@4.0.1",
  "_where": "/Users/vt/Documents/development/canada/src/core/assets/basecode/node_modules/mailcomposer",
  "author": {
    "name": "Andris Reinman",
    "email": "andris@kreata.ee"
  },
  "bugs": {
    "url": "https://github.com/andris9/buildmail/issues"
  },
  "dependencies": {
    "addressparser": "1.0.1",
    "libbase64": "0.1.0",
    "libmime": "3.0.0",
    "libqp": "1.1.0",
    "nodemailer-fetch": "1.6.0",
    "nodemailer-shared": "1.1.0",
    "punycode": "1.4.1"
  },
  "deprecated": "This project is unmaintained",
  "description": "buildmail is a low level rfc2822 message composer. Define your own mime tree, no magic included.",
  "devDependencies": {
    "chai": "~3.5.0",
    "grunt": "~1.0.1",
    "grunt-cli": "^1.2.0",
    "grunt-eslint": "^19.0.0",
    "grunt-mocha-test": "~0.13.2",
    "mocha": "^3.2.0",
    "sinon": "^1.17.7"
  },
  "directories": {},
  "dist": {
    "shasum": "877f7738b78729871c9a105e3b837d2be11a7a72",
    "tarball": "https://registry.npmjs.org/buildmail/-/buildmail-4.0.1.tgz"
  },
  "gitHead": "26157b64673588a54a243c095b35133f298d195b",
  "homepage": "https://github.com/andris9/buildmail#readme",
  "keywords": [
    "RFC2822",
    "mime"
  ],
  "license": "MIT",
  "main": "lib/buildmail",
  "maintainers": [
    {
      "name": "andris",
      "email": "andris@node.ee"
    }
  ],
  "name": "buildmail",
  "optionalDependencies": {},
  "readme": "# buildmail\n\nLow level rfc2822 message composer that streams output. Define your own mime tree, no magic included.\n\nPorted from [MailBuild](https://github.com/whiteout-io/mailbuild) of the [emailjs.org](http://emailjs.org/) project. This port uses similar API but is for Node only and streams the output.\n\n[![Build Status](https://secure.travis-ci.org/nodemailer/buildmail.svg)](http://travis-ci.org/nodemailer/buildmail)\n<a href=\"http://badge.fury.io/js/buildmail\"><img src=\"https://badge.fury.io/js/buildmail.svg\" alt=\"NPM version\" height=\"18\"></a>\n\n## Usage\n\nInstall with npm\n\n    npm install buildmail\n\nRequire in your scripts\n\n```javascript\nvar BuildMail = require('buildmail');\n```\n\n## API\n\nCreate a new `BuildMail` object with\n\n```javascript\nvar builder = new BuildMail(contentType [, options]);\n```\n\nWhere\n\n  * **contentType** - define the content type for created node. Can be left blank for attachments (content type derived from `filename` option if available)\n  * **options** - an optional options object\n    * **filename** - *String* filename for an attachment node\n    * **baseBoundary** - *String* shared part of the unique multipart boundary (generated randomly if not set)\n    * **keepBcc** - *Boolean* If true keep the Bcc value in generated headers (default is to remove it)\n    * **textEncoding** - set default content encoding, either 'base64' or 'quoted-printable'\n    * **hostname** - optional hostname for default Message-Id values. Normally hostname from the `from` address is used but this might not be available\n    * **disableUrlAccess** - if set to true then fails with an error when a node tries to load content from URL\n    * **disableFileAccess** - if set to true then fails with an error when a node tries to load content from a file\n\n## Methods\n\nThe same methods apply to the root node created with `new BuildMail()` and to any child nodes.\n\n### createChild\n\nCreates and appends a child node to the node object\n\n```javascript\nnode.createChild(contentType, options)\n```\n\nThe same arguments apply as with `new BuildMail()`. Created node object is returned.\n\n**Example**\n\n```javascript\nnew BuildMail('multipart/mixed').\n    createChild('multipart/related').\n        createChild('text/plain');\n```\n\nGenerates the following mime tree:\n\n```\nmultipart/mixed\n  â†³ multipart/related\n      â†³ text/plain\n```\n\n### appendChild\n\nAppends an existing child node to the node object. Removes the node from an existing tree if needed.\n\n```javascript\nnode.appendChild(childNode)\n```\n\nWhere\n\n  * **childNode** - child node to be appended\n\nMethod returns appended child node.\n\n**Example**\n\n```javascript\nvar childNode = new BuildMail('text/plain'),\n    rootNode = new BuildMail('multipart/mixed');\nrootnode.appendChild(childNode);\n```\n\nGenerates the following mime tree:\n\n```\nmultipart/mixed\n  â†³ text/plain\n```\n\n## replace\n\nReplaces current node with another node\n\n```javascript\nnode.replace(replacementNode)\n```\n\nWhere\n\n  * **replacementNode** - node to replace the current node with\n\nMethod returns replacement node.\n\n**Example**\n\n```javascript\nvar rootNode = new BuildMail('multipart/mixed'),\n    childNode = rootNode.createChild('text/plain');\nchildNode.replace(new BuildMail('text/html'));\n```\n\nGenerates the following mime tree:\n\n```\nmultipart/mixed\n  â†³ text/html\n```\n\n## remove\n\nRemoves current node from the mime tree. Does not make a lot of sense for a root node.\n\n```javascript\nnode.remove();\n```\n\nMethod returns removed node.\n\n**Example**\n\n```javascript\n\nvar rootNode = new BuildMail('multipart/mixed'),\n    childNode = rootNode.createChild('text/plain');\nchildNode.remove();\n```\n\nGenerates the following mime tree:\n\n```\nmultipart/mixed\n```\n\n## setHeader\n\nSets a header value. If the value for selected key exists, it is overwritten.\n\nYou can set multiple values as well by using `[{key:'', value:''}]` or\n`{key: 'value'}` structures as the first argument.\n\n```javascript\nnode.setHeader(key, value);\n```\n\nWhere\n\n  * **key** - *String|Array|Object* Header key or a list of key value pairs\n  * **value** - *String* Header value\n\nMethod returns current node.\n\n**Example**\n\n```javascript\nnew BuildMail('text/plain').\n    setHeader('content-disposition', 'inline').\n    setHeader({\n        'content-transfer-encoding': '7bit'\n    }).\n    setHeader([\n        {key: 'message-id', value: 'abcde'}\n```\n\nGenerates the following header:\n\n```\nContent-type: text/plain\nContent-Disposition: inline\nContent-Transfer-Encoding: 7bit\nMessage-Id: <abcde>\n```\n\n## addHeader\n\nAdds a header value. If the value for selected key exists, the value is appended\nas a new field and old one is not touched.\n\nYou can set multiple values as well by using `[{key:'', value:''}]` or\n`{key: 'value'}` structures as the first argument.\n\n```javascript\nnode.addHeader(key, value);\n```\n\nWhere\n\n  * **key** - *String|Array|Object* Header key or a list of key value pairs\n  * **value** - *String* Header value or an array of strings to add the same key multiple times\n\nMethod returns current node.\n\n**Example**\n\n```javascript\nnew BuildMail('text/plain').\n    addHeader('X-Spam', '1').\n    setHeader({\n        'x-spam': '2'\n    }).\n    setHeader([\n        {key: 'x-spam', value: '3'}\n    ]);\n```\n\nGenerates the following header:\n\n```\nContent-type: text/plain\nX-Spam: 1\nX-Spam: 2\nX-Spam: 3\n```\n\n## Prepared headers\n\nNormally all headers are encoded and folded to meet the requirement of having plain-ASCII messages with lines no longer than 78 bytes. Sometimes it is preferable to not modify header values and pass these as provided. This can be achieved with the `prepared` option:\n\n```javascript\nnew BuildMail('text/plain').\n    addHeader('X-Long-Header', {\n        prepared: true,\n        value: 'a really long header or value with non-ascii characters ðŸ‘®'\n    });\n\n// normal output:\n// X-Long-Header: a really long header or value with non-ascii characters\n//  =?UTF-8?Q?=F0=9F=91=AE?=\n\n// output with the prepared option:\n// X-Long-Header: a really long header or value with non-ascii characters ðŸ‘®\n```\n\n## getHeader\n\nRetrieves the first mathcing value of a selected key\n\n```javascript\nnode.getHeader(key)\n```\n\nWhere\n\n  * **key** - *String* Key to search for\n\n**Example**\n\n```javascript\nnew BuildMail('text/plain').getHeader('content-type'); // text/plain\n```\n\n## buildHeaders\n\nBuilds the current header info into a header block that can be used in an e-mail\n\n```javascript\nvar headers = node.buildHeaders()\n```\n\n**Example**\n\n```javascript\nnew BuildMail('text/plain').\n    addHeader('X-Spam', '1').\n    setHeader({\n        'x-spam': '2'\n    }).\n    setHeader([\n        {key: 'x-spam', value: '3'}\n    ]).buildHeaders();\n```\n\nreturns the following String\n\n```\nContent-Type: text/plain\nX-Spam: 3\nDate: Sat, 21 Jun 2014 10:52:44 +0000\nMessage-Id: <1403347964894-790a5296-0eb7c7c7-6440334f@localhost>\nMIME-Version: 1.0\n```\n\nIf the node is the root node, then `Date` and `Message-Id` values are generated automatically if missing\n\n## setContent\n\nSets body content for current node. If the value is a string and Content-Type is text/* then charset is set automatically.\nIf the value is a Buffer or a Stream you need to specify the charset yourself.\n\n```javascript\nnode.setContent(body)\n```\n\nWhere\n\n  * **body** - *String|Buffer|Stream|Object* body content\n\nIf the value is an object, it should include one of the following properties\n\n  * **path** - path to a file that will be used as the content\n  * **href** - URL that will be used as the content\n\n**Example**\n\n```javascript\nnew BuildMail('text/plain').setContent('Hello world!');\n\nnew BuildMail('text/plain; charset=utf-8').setContent(fs.createReadStream('message.txt'));\n```\n\n## setRaw\n\nSets pre-generated output value for current node. When building the final message\nthen this value is returned instead of building a fresh rfc822 mime message from\nnormal input.\n\nThis also means that other methods (`getAddresses`, `getEnvelope` etc.) that use normal\ninput do not return valid values as the raw message is not parsed. You must set\nenvelope contents manually with `setEnvelope` and you probably should set the\n*Message-Id* header (even though it wouldn't break anything if you would not set it).\n\n```javascript\nnode.setRaw(message)\n```\n\nWhere\n\n  * **message** - *String|Buffer|Stream|Object* MIME message\n\nIf the value is an object, it should include one of the following properties\n\n  * **path** - path to a file that will be used as the content\n  * **href** - URL that will be used as the content\n\n**Example**\n\n```javascript\nnew BuildMail().setRaw(fs.createReadStream('message.eml'));\n```\n\n\n## build\n\nBuilds the rfc2822 message from the current node. If this is a root node, mandatory header fields are set if missing (Date, Message-Id, MIME-Version)\n\n```javascript\nnode.build(callback)\n```\n\nCallback returns the rfc2822 message as a Buffer\n\n**Example**\n\n```javascript\nnew BuildMail('text/plain').setContent('Hello world!').build(function(err, mail){\n    console.log(mail.toString('ascii'));\n});\n```\n\nReturns the following string:\n\n```\nContent-type: text/plain\nDate: <current datetime>\nMessage-Id: <generated value>\nMIME-Version: 1.0\n\nHello world!\n```\n\n## createReadStream\n\nIf you manage large attachments you probably do not want to generate but stream the message.\n\n```javascript\nvar stream = node.createReadStream(options)\n```\n\nWhere\n\n  * **options** - *Object* optional Stream options (ie. `highWaterMark`)\n\n**Example**\n\n```javascript\nvar message = new BuildMail();\nmessage.addHeader({\n    from: 'From <from@example.com>',\n    to: 'receiver1@example.com',\n    cc: 'receiver2@example.com'\n});\nmessage.setContent(fs.createReadStream('message.txt'));\nmessage.createReadStream().pipe(fs.createWriteStream('message.eml'));\n```\n\n## transform\n\nIf you want to modify the created stream, you can add transform streams that the output will be piped through.\n\n```javascript\nnode.transform(transformStream)\n```\n\nWhere\n\n  * **transformStream** - *Stream* or *Function* Transform stream that the output will go through before returing with `createReadStream`. If the value is a function the function should return a transform stream object when called.\n\n**Example**\n\n```javascript\nvar PassThrough = require('stream').PassThrough;\nvar message = new BuildMail();\nmessage.addHeader({\n    from: 'From <from@example.com>',\n    to: 'receiver1@example.com',\n    cc: 'receiver2@example.com'\n});\nmessage.setContent(fs.createReadStream('message.txt'));\nmessage.transform(new PassThrough()); // add a stream that the output will be piped through\nmessage.createReadStream().pipe(fs.createWriteStream('message.eml'));\n```\n\n## setEnvelope\n\nSet envelope object to use. If one is not set, it is generated based ong the headers.\n\n```javascript\nnode.setEnvelope(envelope)\n```\n\nWhere\n\n  * **envelope** is an envelope object in the form of `{from:'address', to: ['addresses']}`\n\n## getEnvelope\n\nGenerates a SMTP envelope object. Makes sense only for root node.\n\n```javascript\nvar envelope = node.generateEnvelope()\n```\n\nMethod returns the envelope in the form of `{from:'address', to: ['addresses']}`\n\n**Example**\n\n```javascript\nnew BuildMail().\n    addHeader({\n        from: 'From <from@example.com>',\n        to: 'receiver1@example.com',\n        cc: 'receiver2@example.com'\n    }).\n    getEnvelope();\n```\n\nReturns the following object:\n\n```javascript\n{\n    from: 'from@example.com',\n    to: ['receiver1@example.com', 'receiver2@example.com']\n}\n```\n\n## messageId\n\nReturns Message-Id value. If it does not exist then generates one.\n\n```javascript\nvar messageId = node.messageId();\n```\n\nMethod returns the Message-Id value `<unique-message-id@example.com`\n\n**Example**\n\n```javascript\nnew BuildMail().\n    addHeader({\n        from: 'From <from@example.com>'\n    }).\n    messageId();\n```\n\nReturns the following value:\n\n```javascript\n\"<1453237212620-0657660b-8df9255d-18bcdcb5@example.com>\"\n```\n\n## getAddresses\n\nReturns an address container object. Includes all parsed addresses from From, Sender, To, Cc, Bcc and Reply-To fields.\n\nWhile `getEnvelope()` returns 'from' value as a single address (the first one encountered) then `getAddresses` return all values as arrays, including `from`. Additionally while `getEnvelope` returns only `from` and a combined `to` value then `getAddresses` returns all fields separately.\n\nPossbile return values (all arrays in the form of `[{name:'', address:''}]`):\n\n  * **from**\n  * **sender**\n  * **'reply-to'**\n  * **to**\n  * **cc**\n  * **bcc**\n\nIf no addresses were found for a particular field, the field is not set in the response object.\n\n**Example**\n\n```javascript\nnew BuildMail().\n    addHeader({\n        from: 'From <from@example.com>',\n        to: '\"Receiver\" receiver1@example.com',\n        cc: 'receiver2@example.com'\n    }).\n    getAddresses();\n```\n\nReturns the following object:\n\n```javascript\n{\n    from: [{\n        name: 'From',\n        address: 'from@example.com'\n    }],\n    to: [{\n        name: 'Receiver',\n        address: 'receiver1@example.com'\n    }],\n    cc: [{\n        name: '',\n        address: 'receiver2@example.com'\n    }]\n}\n```\n\n## Notes\n\n### Addresses\n\nWhen setting address headers (`From`, `To`, `Cc`, `Bcc`) use of unicode is allowed. If needed\nthe addresses are converted to punycode automatically.\n\n### Attachments\n\nFor attachments you should minimally set `filename` option and `Content-Disposition` header. If filename is specified, you can leave content type blank - if content type is not set, it is detected from the filename.\n\n```javascript\nnew BuildMail('multipart/mixed').\n  createChild(false, {filename: 'image.png'}).\n  setHeader('Content-Disposition', 'attachment');\n```\n\nObviously you might want to add `Content-Id` header as well if you want to reference this attachment from the HTML content.\n\n### MIME structure\n\nMost probably you only need to deal with the following multipart types when generating messages:\n\n  * **multipart/alternative** - includes the same content in different forms (usually text/plain + text/html)\n  * **multipart/related** - includes main node and related nodes (eg. text/html + referenced attachments). Also requires a `type` parameter that indicates the Content-Type of the *root* element in the node\n  * **multipart/mixed** - includes other multipart nodes and attachments, or single content node and attachments\n\n**Examples**\n\nOne content node and an attachment\n\n```\nmultipart/mixed\n  â†³ text/plain\n  â†³ image/png\n```\n\nContent node with referenced attachment (eg. image with `Content-Type` referenced by `cid:` url in the HTML)\n\n```\nmultipart/related\n  â†³ text/html\n  â†³ image/png\n```\n\nPlaintext and HTML alternatives\n\n```\nmultipart/alternative\n  â†³ text/html\n  â†³ text/plain\n```\n\nOne content node with referenced attachment and a regular attachment\n\n```\nmultipart/mixed\n  â†³ multipart/related\n    â†³ text/plain\n    â†³ image/png\n  â†³ application/x-zip\n```\n\nAlternative content with referenced attachment for HTML and a regular attachment\n\n```\nmultipart/mixed\n  â†³ multipart/alternative\n    â†³ text/plain\n    â†³ multipart/related\n      â†³ text/html\n      â†³ image/png\n  â†³ application/x-zip\n```\n\n## License\n\n**MIT**\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git://github.com/andris9/buildmail.git"
  },
  "scripts": {
    "test": "grunt mochaTest"
  },
  "version": "4.0.1"
}
