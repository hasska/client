{
  "_args": [
    [
      {
        "raw": "mux-demux@^3.7.9",
        "scope": null,
        "escapedName": "mux-demux",
        "name": "mux-demux",
        "rawSpec": "^3.7.9",
        "spec": ">=3.7.9 <4.0.0",
        "type": "range"
      },
      "/Users/vt/Documents/development/canada/src/core/assets/basecode/node_modules/strong-remoting"
    ]
  ],
  "_from": "mux-demux@>=3.7.9 <4.0.0",
  "_id": "mux-demux@3.7.9",
  "_inCache": true,
  "_location": "/mux-demux",
  "_npmUser": {
    "name": "dominictarr",
    "email": "dominic.tarr@gmail.com"
  },
  "_npmVersion": "1.4.9",
  "_phantomChildren": {},
  "_requested": {
    "raw": "mux-demux@^3.7.9",
    "scope": null,
    "escapedName": "mux-demux",
    "name": "mux-demux",
    "rawSpec": "^3.7.9",
    "spec": ">=3.7.9 <4.0.0",
    "type": "range"
  },
  "_requiredBy": [
    "/strong-remoting"
  ],
  "_resolved": "https://registry.npmjs.org/mux-demux/-/mux-demux-3.7.9.tgz",
  "_shasum": "35367718fd3601c80bce2eb762531576d7a4acef",
  "_shrinkwrap": null,
  "_spec": "mux-demux@^3.7.9",
  "_where": "/Users/vt/Documents/development/canada/src/core/assets/basecode/node_modules/strong-remoting",
  "author": {
    "name": "Dominic Tarr",
    "email": "dominic.tarr@gmail.com",
    "url": "dominictarr.com"
  },
  "bugs": {
    "url": "https://github.com/dominictarr/mux-demux/issues"
  },
  "dependencies": {
    "duplex": "~1.0.0",
    "json-buffer": "~2.0.4",
    "msgpack-stream": "~0.0.10",
    "stream-combiner": "0.0.2",
    "stream-serializer": "~1.1.1",
    "through": "~2.3.1",
    "xtend": "~1.0.3"
  },
  "description": "multiplex streams",
  "devDependencies": {
    "event-stream": "~3.0.7",
    "tape": "~0.2.2"
  },
  "directories": {},
  "dist": {
    "shasum": "35367718fd3601c80bce2eb762531576d7a4acef",
    "tarball": "https://registry.npmjs.org/mux-demux/-/mux-demux-3.7.9.tgz"
  },
  "homepage": "http://github.com/dominictarr/mux-demux",
  "maintainers": [
    {
      "name": "dominictarr",
      "email": "dominic.tarr@gmail.com"
    }
  ],
  "name": "mux-demux",
  "optionalDependencies": {},
  "readme": "# MuxDemux\n\nmultiplex-demultiplex object streams across _any_ text stream.\n\n[![Build Status](https://travis-ci.org/dominictarr/mux-demux.png)]\n  (https://travis-ci.org/dominictarr/mux-demux)\n\n## Stability\n\nStable: Expect patches, possible features additions.\n\n## Example\n\n``` js\nvar MuxDemux = require('mux-demux')\nvar net = require('net')\n\nnet.createServer(function (con) {\n  con.pipe(MuxDemux(function (stream) {\n    stream.on('data', console.log.bind(console))\n  })).pipe(con)\n}).listen(8642, function () {\n  var con = net.connect(8642), mx\n  con.pipe(mx = MuxDemux()).pipe(con)\n\n  var ds = mx.createWriteStream('times')\n\n  setInterval(function () {\n    ds.write(new Date().toString())\n  }, 1e3)\n})\n```\n\n## Binary Support\n\nBy encoding JSON as msgpack, binary is supported.\njust require from `mux-demux/msgpack` instead of `mux-demux`.\n\n``` js\nvar MuxDemux = requrie('mux-demux/msgpack')\n```\n\n## Gotchas\n\ntake care to create a `MuxDemux` instance per connection,\ndo not connect many connections to one `MuxDemux'.\n\n### Right\n\n``` js\nnet.createServer(function (stream) {\n  stream.pipe(MuxDemux(function (_stream) { \n\n  }).pipe(stream)\n}).listen(port)\n```\n\n### WRONG!\n``` js\nvar mx = MuxDemux()\nnet.createServer(function (stream) {\n  //this will connect many streams to the OUTER MuxDemux Stream!\n  stream.pipe(mx).pipe(stream)\n}).listen(port)\n```\n\n### Errors, and use in PRODUCTION\n\n`mux-demux` parses a `JSON` protocol, and so you must handle any errors\nthat may result from someone connecting, and sending invalid data.\n\n``` js\nnet.createServer(function (stream) {\n  var mx = MuxDemux()\n  stream.pipe(mx).pipe(stream)\n  mx.on('error', function () {\n    stream.destroy()\n  })\n  stream.on('error', function () {\n    mx.destroy()\n  })\n}).listen(9999)\n```\n\n#API\n\nthe API [browser-stream](http://github.com/dominictarr/browser-stream#api)\n\n``` js\n\nvar MuxDemux = require('mux-demux')\nvar a = MuxDemux()\nvar b = MuxDemux()\n\na.pipe(b).pipe(a)\n\nb.on('connection', function (stream) {\n  // inspect stream.meta to decide what this stream is.\n})\n\na.createWriteStream(meta)\na.createReadStream(meta)\na.createStream(meta)\n\n```\nthere is actually no distinction between clients and servers.\nif both sides are listening `on('connection',...)` then both sides may call `create{Write,Read,}Stream(meta)` and initiate new streams.\n\n### MuxDemux(options, onConnection)\n\nCreates a MuxDemux stream. Optionally pass in an options hash \n\n    {\n        error: Boolean,\n        wrapper: function (stream) {...}\n    }\n\nIf the error option is set to true  then MuxDemux will emit errors on the \nstreams on unexpected disconnects. othewise, it will just emit 'end' on those streams.\n\n`wrapper` be used to change the serialization format used by `mux-demux`,\nby default, line seperated json is used. see examples [below](#wrapper_examples)\nboth mux-demux end points must use the same wrapper.\n\n`options` is optional. `MuxDemux(onConnection)` is a shortcut \nfor `MuxDemux().on('connection', onConnection)`\n\n### createReadStream (meta)\n\nopen a `ReadableStream` from the other side.\nreturns a `ReadableStream`.\nthe other side of connection will emit a writable stream that is connected to this stream.\n\n### createWriteStream (meta)\n\nopen a `WritableStream` to the other side.\nreturns a `WritableStream`, the other side will emit a `ReadableStream` connected to this stream.\n\n### createStream (meta, opts)\n\nopen a `Stream` to the other side which is both readable and writable.\nreturns a `Stream`, the other side will emit a `Stream` connected to this stream.\n\nopts may be `{allowHalfOpen: true}`, if this is not set, the stream will emit\n`'end'` when `end()` is called. this may cause the stream to loose some data \nfrom the other end. If `allowHalfOpen` is `true` then the remote end must call `end()`.\n\n> note to self, references to a class (`Stream`) should be capitalized, and in backticks.\n> references to an instance should be lowercase, and not in backticks unless refuring to\n> a specific variable in a code example.\n\n### close(cb)\n\nasks mux-demux to emit end once all the sub-streams have closed.\nthis will wait untill they have ended, closed, or errored, just like \n[`net.Server#close`](http://nodejs.org/api/net.html#net_server_close_cb).\n\nTakes an optional callback, and emits the 'end' event. \n\n### Wrapper Examples\n\nA stream of plain old js objects.\n\n``` js\nnew MuxDemux({wrapper: function (stream) { return stream } })\n```\n\nA stream of msgpack.\n\n``` js\nvar es = require('event-stream')\nvar ms = require('msgpack-stream')\n\nnew MuxDemux({wrapper: function (stream) { \n  return es.pipeline(ms.createDecodeStream(), stream, ms.createEncodeStream()) \n}})\n\n```\n\n### MuxDemuxStream#error\n\nthere is one addition to the stream interface. call `stream.error(err)`\nwill send an error that will be emitted at the other side of the stream.\nthis is useful for sending 404 like messages to clients, etc.\n",
  "readmeFilename": "readme.markdown",
  "repository": {
    "type": "git",
    "url": "git://github.com/dominictarr/mux-demux.git"
  },
  "scripts": {
    "test": "set -e; for t in test/*.js; do node $t; done"
  },
  "stability": "stable",
  "testling": {
    "files": "test/*.js",
    "browsers": {
      "ie": [
        8,
        9,
        10
      ],
      "firefox": [
        17,
        18
      ],
      "chrome": [
        23,
        24
      ],
      "safari": [
        5,
        6
      ],
      "opera": [
        12
      ]
    }
  },
  "version": "3.7.9"
}
